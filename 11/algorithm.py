# 알고리즘

# 거듭제곱, 로그(거듭제곱의 반대)
# a의 x승 = b  =>  log a의 b = x (b를 a로 몇 번 나누어야 1이 되는가?**)



# 선형 탐색(Linear Search): 리스트의 처음부터 끝까지 순서대로 하나씩 탐색을 진행하는 알고리즘// 어떤 원소가 리스트 안에 포함되어 있는지 확인하는 것

# 파라미터로 탐색할 값 element와 리스트 some_list를 받는 함수 linear_search를 작성하세요. 
# 0번 인덱스부터 순서대로 하나씩 확인해서 만약 element를 some_list에서 발견할 시 그 위치(인덱스)를 리턴해주면 됩니다. 
# element가 some_list에 존재하지 않는 값이면 None을 리턴해주세요.

# <주의> 'if 원소 in 리스트'의 'in' 키워드 또는 'if 원소 not in 리스트'의 'not in' 키워드는 사용하면 안됩니다. 
# 왜냐하면 'in' 키워드는 탐색 알고리즘 자체의 결과를 불러오기 때문에, 해당 키워드를 사용하지 않고 알고리즘을 직접 구현하셔야 합니다. 



# 템플릿 (Template)

def linear_search(element, some_list):
    # 코드를 작성하세요.

print(linear_search(2, [2, 3, 5, 7, 11]))
print(linear_search(0, [2, 3, 5, 7, 11]))
print(linear_search(5, [2, 3, 5, 7, 11]))
print(linear_search(3, [2, 3, 5, 7, 11]))
print(linear_search(11, [2, 3, 5, 7, 11]))



# 출력 결과

# 0
# None
# 2
# 1
# 4










# 이진 탐색(반복문) : 선형 탐색 알고리즘과 달리, 정렬된 리스트를 전제로// 정렬된 리스트가 아니면 이 알고리즘은 적용이 불가능//어떤 원소가 리스트 안에 포함되어 있는지 확인하기 위함
# 1회 비교를 거칠 때마다 탐색 범위가 절반으로 줄어들기 때문

# <주의> 'if 원소 in 리스트'의 'in' 키워드 또는 'if 원소 not in 리스트'의 'not in' 키워드는 사용하면 안됩니다. 
# 왜냐하면 'in' 키워드는 탐색 알고리즘 자체의 결과를 불러오기 때문에, 해당 키워드를 사용하지 않고 알고리즘을 직접 구현하셔야 합니다. 

"""
# 예시

예를 들어 [1, 2, 3, 5, 8, 13, 21, 34, 55]에서 3을 찾는 경우, 알고리즘의 진행 방식은 다음과 같습니다:


시도 1

리스트의 첫 번째 인덱스와 마지막 인덱스의 값을 합하여 2로 나눈 후, 중간 인덱스로 지정합니다. 그리고 그 인덱스에 해당하는 값이 3인지 확인해봅니다.


이 경우 리스트의 첫 번째 인덱스는 0이고 마지막 인덱스는 8이므로, 중간 인덱스는 4이고 해당 원소는 8입니다.


찾고자 하는 원소(3)는 중간 원소(8)에 비해 작습니다. 리스트는 정렬되어있으므로, 인덱스 4~8은 탐색 범위에서 제외됩니다. 탐색 범위가 절반으로 줄어든 것이죠.


시도 2

탐색 범위는 이제 인덱스 0~3입니다. 탐색 범위의 리스트의 첫 번째 인덱스는 0이고 마지막 인덱스는 3이므로, 중간 인덱스는 (0 + 3) // 2인 1입니다. 인덱스 1에 해당 원소는 2이죠.


찾고자 하는 원소(3)는 중간 원소(2)에 비해 큽니다. 리스트는 정렬되어 있으므로, 인덱스 0~1은 탐색 범위에서 제외됩니다. 탐색 범위가 다시 절반으로 줄어든 것이죠.


시도 3

탐색 범위는 이제 인덱스 2~3입니다. 탐색 범위의 리스트의 첫 번째 인덱스는 2이고 마지막 인덱스는 3이므로, 중간 인덱스는 (2 + 3) // 2인 2입니다. 인덱스 2에 해당하는 원소의 값은 3이죠.


찾고자 하는 원소(3)는 중간에 해당하는 원소(3)와 일치합니다. 값을 찾았으니, 인덱스 2를 리턴해주며, 알고리즘을 종료합니다.

"""




# 템플릿 (Template)

def binary_search(element, some_list):
    # 코드를 작성하세요.

print(binary_search(2, [2, 3, 5, 7, 11]))
print(binary_search(0, [2, 3, 5, 7, 11]))
print(binary_search(5, [2, 3, 5, 7, 11]))
print(binary_search(3, [2, 3, 5, 7, 11]))
print(binary_search(11, [2, 3, 5, 7, 11]))

# 0
# None
# 2
# 1
# 4










# 이진 탐색(재귀)

"""
템플릿에 있는 함수 정의를 보시면 optional parameter를 사용하는데요. 이 내용이 기억 안 나시면 '추상화' 섹션의 '추상화 꿀팁' 노트를 보시면 됩니다!


end_index의 기본값을 None으로 설정한 후, 함수 내에서 len(some_list) - 1로 바꾼 이유가 궁금하실 것입니다. 파라미터를 받을 때 파이썬은 some_list의 존재를 모르기 때문에, 정의를 이렇게:


def binary_search(element, some_list, start_index = 0, end_index = len(some_list) - 1):

쓰면 이런 오류 메시지가 나옵니다:


NameError: name 'some_list' is not defined

이 때문에 먼저 None으로 설정한 후, 함수 안에서 end_index의 값이 특별히 설정되지 않았을 경우에는 end_index를 len(some_list) - 1로 바꾸어주는 것입니다.


반드시 재귀(recursion)의 개념을 사용하셔야 합니다. 이진 탐색 개념이 꽤 어려우니, 천천히 고민해보시기 바랍니다!


평소 재귀 문제를 풀 때처럼 Base Case와 Recursive Case를 생각하시는 것이 핵심입니다!

"""
# <주의> 'if 원소 in 리스트'의 'in' 키워드 또는 'if 원소 not in 리스트'의 'not in' 키워드는 사용하면 안됩니다. 
# 왜냐하면 'in' 키워드는 탐색 알고리즘 자체의 결과를 불러오기 때문에, 해당 키워드를 사용하지 않고 알고리즘을 직접 구현하셔야 합니다. 



# 템플릿 (Template)

def binary_search(element, some_list, start_index = 0, end_index = None):
    if end_index == None:
        end_index = len(some_list) - 1

    # 코드를 작성하세요.

print(binary_search(2, [2, 3, 5, 7, 11]))
print(binary_search(0, [2, 3, 5, 7, 11]))
print(binary_search(5, [2, 3, 5, 7, 11]))
print(binary_search(3, [2, 3, 5, 7, 11]))
print(binary_search(11, [2, 3, 5, 7, 11]))


# 0
# None
# 2
# 1
# 4










# 선형 탐색(차례대로 서치) vs. 이진 탐색(절반 값부터 서치)

# 길이가 n일 때 선형 탐색 가장 금방 되는 경우(0번 인덱스에서 바로 한번에) : 1 
# 가장 오래 걸리는 경우 : n(모두 다)

# 길이가 n일 때 이진 탐색 가장 금방 되는 경우(가운데 인덱스에서 바로 한번에) : 1 
# 가장 오래 걸리는 경우 : (계속 반토막 내서)lg n(log작은2의 n)((+ 찾는 값이 리스트 값보다 작으면 없애는)계속 반 씩 줄어들면서 다 없애면서 찾는)

# 2진 탐색이 시간 훨씬 줄어든다













# Asymptotic Analysis(점근 표기법/ Big-O) : 
# n이 아주 크다!고 가정해서//2 * n의 3승 + 15*n의 제곱 + n + 394 -> (미미한 값이니까 다버리고) n의 3승

# 20n + 40    ->    O(n) : 빅 O of n 알고리즘//n이 2배되면 걸리는 시간도 2배
# 2*n의 제곱 + 8n + 157    ->    O(n의 제곱)//n이 2배되면 걸리는 시간은 4배
# n의 세제곱 + 15 *n의 제곱 + n + 394    ->   O(n의 세제곱)//n이 2배되면 걸리는 시간은 8배